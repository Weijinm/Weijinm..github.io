<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>课程复习：嵌入式软件开发-02ARM C程序优化设计</title>
      <link href="/2022/12/20/0002-02-02/"/>
      <url>/2022/12/20/0002-02-02/</url>
      
        <content type="html"><![CDATA[<h2 id="优化概述"><a href="#优化概述" class="headerlink" title="优化概述"></a>优化概述</h2><p>代码优化：时间优化、空间优化</p><p>代码优化与程序的可读性相互矛盾</p><p>需要优先优化的代码对象是那些频繁使用的代码</p><hr><h2 id="局部变量类型"><a href="#局部变量类型" class="headerlink" title="局部变量类型"></a>局部变量类型</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p>尽量采用int、long类型（这两个都是4字节的数据，long在linux64环境下是8字节，不过基本没必要管）</p><p>仅使用char、short的溢出归零特性</p><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p>虽然说char能表示-127~128的值，且咋一看更节省寄存器和内存空间，但实际上在32位系统中，寄存器也是32位的（#0000 ~ #ffff），所以会在变动char类型数据后会进行一次与#0xff的按位与运算，来确保数据不超过255。这样就使代码多了一行语句，如下例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">checksum_v1</span><span class="params">(<span class="type">int</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> i;<span class="comment">//设置为char的变量。要是变量类型为unsigned int的话能少掉下面标注了的那一行</span></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">sum += data[i];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Typora的时候这一段代码能以assembly渲染，但是Butterfly并不能直接对assembly进行渲染，就用Markdown凑合吧()</p><p>汇编指令不记得的话可以去这个网站看看<a href="https://www.softool.cn/read/arm_assembly/instruction.html">ARM汇编-指令</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">checksum<span class="emphasis">_v1_</span>s</span><br><span class="line"><span class="code">MOVr2,r0                   ; r2 = data，地址指针</span></span><br><span class="line"><span class="code">MOVr0,#0                   ; sum = 0</span></span><br><span class="line"><span class="code">MOVr1,#0                   ; i = 0，计数器</span></span><br><span class="line"><span class="code">checksum_v1_loop</span></span><br><span class="line"><span class="code">LDRr3,[r2,r1,LSL #2]       ; r3 = data[i], r1左移2位, 对应跳2^2=4字节数据</span></span><br><span class="line"><span class="code">ADDr1,r1,#1                ; r1 = i+1</span></span><br><span class="line"><span class="code">ANDr1,r1,#0xff             ; i = (char)r1, 由于用了char型数据而增添的一行语句</span></span><br><span class="line"><span class="code">CMPr1,#0x40                ; compare i, 64</span></span><br><span class="line"><span class="code">ADDr0,r3,r0                ; sum += r3</span></span><br><span class="line"><span class="code">BCCchecksum_v1_loop        ; if (i&lt;64) loop</span></span><br><span class="line"><span class="code">MOVpc,r14                  ; return sum</span></span><br></pre></td></tr></table></figure><hr><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p>然后对情况进行变化，需要校验的数据为16位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="title function_">checksum_v3</span><span class="params">(<span class="type">short</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="type">short</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">sum = (<span class="type">short</span>)(sum + data[i]);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">checksum<span class="emphasis">_v3_</span>s</span><br><span class="line"><span class="code">MOV r2,r0 ; r2 = data</span></span><br><span class="line"><span class="code">MOV r0,#0 ; sum = 0</span></span><br><span class="line"><span class="code">MOV r1,#0 ; i = 0</span></span><br><span class="line"><span class="code">checksum_v3_loop</span></span><br><span class="line"><span class="code">ADD r3,r2,r1,LSL #1 ; r3 = &amp;data[i] ←</span></span><br><span class="line"><span class="code">LDRH r3,[r3,#0] ; r3 = data[i]  ←</span></span><br><span class="line"><span class="code">ADD r1,r1,#1 ; i++</span></span><br><span class="line"><span class="code">CMP r1,#0x40 ; compare i, 64</span></span><br><span class="line"><span class="code">ADD r0,r3,r0 ; r0 = sum + r3</span></span><br><span class="line"><span class="code">MOV r0,r0,LSL #16; ←</span></span><br><span class="line"><span class="code">MOV r0,r0,ASR #16 ; sum = (short)r0, 左移16位再右移16位，抹去高位 ←</span></span><br><span class="line"><span class="code">BCC checksum_v3_loop ; if (i&lt;64) goto loop</span></span><br><span class="line"><span class="code">MOV pc,r14 ; return sum</span></span><br></pre></td></tr></table></figure><p>此处保留低16位用的是移位操作而不是按位与，个人想法是和时间代价有关，然后我去找了一下，并没有找到直接的关于按位逻辑与和移位操作的优劣，不过找到了这篇文章，还是能有些启发的：<a href="https://www.dzsc.com/dzbbs/20050626/200765193823531286.html">单片机C语言中移位操作的效率与乘法比较</a>。</p><blockquote><p>这里<em>checksum_v3</em>的<strong>获得地址</strong>的操作和前面<em>checksum_v1</em>的基本一致，对比思考可以发现<em>checksum_v1</em>用的操作是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略其他内容，设一个地址指针 loc，loop后的内容表示放在循环内</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//loop</span></span><br><span class="line">loc = &amp;data[i];</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><p>而后续的<em>checksum_v4</em>中的处理则如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略其他内容，设一个地址指针 loc，loop后的内容表示放在循环内</span></span><br><span class="line"><span class="comment">//loop</span></span><br><span class="line">loc = data;</span><br><span class="line">data++;</span><br></pre></td></tr></table></figure><p>显然，后续的方法代码可读性更差，但同时其效率更优</p></blockquote><hr><h3 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h3><p>可以看到，上述代码中有两处可以优化的地方：</p><ol><li>LDRH指令与LDR不同，不支持移位地址偏移，所以用一条指令单独计算地址。</li><li>用了两次移位来满足short数据类型的需求。这步不可或缺，但是放在循环内就比较低效了。</li></ol><p>那么我们先简单进行一下优化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="title function_">checksum_v3_1</span><span class="params">(<span class="type">short</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="type">short</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">sum = sum + data[i];</span><br><span class="line">sum = (<span class="type">short</span>)sum;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">checksum<span class="emphasis">_v3_</span>1<span class="emphasis">_s</span></span><br><span class="line"><span class="emphasis">MOV r2,r0; r2 = data</span></span><br><span class="line"><span class="emphasis">MOV r0,#0; sum = 0</span></span><br><span class="line"><span class="emphasis">MOV r1,#0; i = 0</span></span><br><span class="line"><span class="emphasis">checksum_</span>v3<span class="emphasis">_1_</span>loop</span><br><span class="line"><span class="code">LDRr3,[r2,r1,LSL #1]; 换成了和checksum_v1一样的形式，少了一行代码</span></span><br><span class="line"><span class="code">ADD r1,r1,#1; i++</span></span><br><span class="line"><span class="code">CMP r1,#0x40; compare i, 64</span></span><br><span class="line"><span class="code">ADD r0,r3,r0; r0 = sum + r3</span></span><br><span class="line"><span class="code">BCC checksum_v3_loop; if (i&lt;64) goto loop</span></span><br><span class="line"><span class="code">MOV r0,r0,LSL #16; 将调整类型的工作移动至循环外，虽然没有减少代码，但也实现了优化</span></span><br><span class="line"><span class="code">MOV r0,r0,ASR #16; sum = (short)r0</span></span><br><span class="line"><span class="code">MOV pc,r14; return sum</span></span><br></pre></td></tr></table></figure><hr><h3 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h3><p>好了，然后再考虑剩下的可以优化的地方。上面checksum_v3例子的末尾，我提到了取地址的方式，那么在对这一块进行优化，是不是可以省去一条”i &#x3D; 0”呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="title function_">checksum_v4</span><span class="params">(<span class="type">short</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">sum += *data++;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">short</span>)sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">checksum<span class="emphasis">_v4_</span>s</span><br><span class="line"><span class="code">MOV r2,#0 ; sum = 0</span></span><br><span class="line"><span class="code">MOV r1,#0 ; i = 0</span></span><br><span class="line"><span class="code">checksum_v4_loop</span></span><br><span class="line"><span class="code">LDRSH r3,[r0],#2 ; r3 = *(data++)</span></span><br><span class="line"><span class="code">ADD r1,r1,#1 ; i++</span></span><br><span class="line"><span class="code">CMP r1,#0x40 ; compare i, 64</span></span><br><span class="line"><span class="code">ADD r2,r3,r2 ; sum += r3</span></span><br><span class="line"><span class="code">BCC checksum_v4_loop ; if (sum&lt;64) goto loop</span></span><br><span class="line"><span class="code">MOV r0,r2,LSL #16</span></span><br><span class="line"><span class="code">MOV r0,r0,ASR #16 ; r0 = (short)sum</span></span><br><span class="line"><span class="code">MOV pc,r14 ; return r0</span></span><br></pre></td></tr></table></figure><hr><h2 id="函数参数类型"><a href="#函数参数类型" class="headerlink" title="函数参数类型"></a>函数参数类型</h2><h3 id="总述-1"><a href="#总述-1" class="headerlink" title="总述"></a>总述</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 学习, 嵌入式相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课程复习：嵌入式软件开发-01绪论</title>
      <link href="/2022/12/19/0002-01-01/"/>
      <url>/2022/12/19/0002-01-01/</url>
      
        <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><em>该文章内容未完成</em></p><h3 id="嵌入式系统的概念"><a href="#嵌入式系统的概念" class="headerlink" title="嵌入式系统的概念"></a>嵌入式系统的概念</h3><ul><li><p>嵌入式系统是控制、监视或者辅助某个设备、机器甚至工厂运行的设备。</p></li><li><p>用来执行特定功能</p></li><li><p>以微电脑与周边构成核心</p></li><li><p>需要严格的时序与稳定度</p></li><li><p>全自动操作循环</p></li></ul><p>国内普遍接受的概念：嵌入式系统是以应用为中心，以计算机技术为基础，软件硬件可裁减，适用于应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。</p><h3 id="嵌入式系统举例"><a href="#嵌入式系统举例" class="headerlink" title="嵌入式系统举例"></a>嵌入式系统举例</h3><p><img src="/img/page-2/page-1-1.jpg"></p><h3 id="嵌入式系统的组成"><a href="#嵌入式系统的组成" class="headerlink" title="嵌入式系统的组成"></a>嵌入式系统的组成</h3><p>这块详细内容较多，ppt P14-21</p><p>硬件组成：嵌入式处理器（必需）、外围电路（必需）、接口、外设</p><p>软件组成：嵌入式操作系统、嵌入式图形系统（可选）、嵌入式应用软件（必需）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习, 嵌入式相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站初步建立啦~</title>
      <link href="/2022/12/17/0001-%E7%BD%91%E7%AB%99%E5%88%9D%E6%AD%A5%E5%BB%BA%E7%AB%8B/"/>
      <url>/2022/12/17/0001-%E7%BD%91%E7%AB%99%E5%88%9D%E6%AD%A5%E5%BB%BA%E7%AB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="网站初步建立啦"><a href="#网站初步建立啦" class="headerlink" title="网站初步建立啦~"></a>网站初步建立啦~</h2><p>经过很长一段时间的考虑（和摆烂，主要是摆烂），趁着这几天课程结束+考试延后+宅家躲阳，先简单摸了个博客上线了，虽然这会儿我的域名和服务器离到期还剩购买的一半不到时间hhhhhh。反正现在有了起步就是好事，之前一直想着用博客留点笔记啥的，都因为没建立好网站而懒得做了，不过现在就没有那种“啊，我网站还没搭好，github不太会，CSDN不想用”这类想法了。</p><p>接下来就是慢慢学着makedown格式文档的编写了，不过这个也不难，一点点试吧。就从这篇文章开始！</p><p>不过现在网站都还是挂载在github上的，之后再转移到自己的服务器上吧。</p><h3 id="这个是三级标题"><a href="#这个是三级标题" class="headerlink" title="这个是三级标题"></a>这个是三级标题</h3><p>就是在试着用一下三级标题而已。</p><h3 id="尝试代码块"><a href="#尝试代码块" class="headerlink" title="尝试代码块"></a>尝试代码块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// printf() 中字符串需要引号</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试文本样式"><a href="#尝试文本样式" class="headerlink" title="尝试文本样式"></a>尝试文本样式</h3><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<del>删除</del>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><h3 id="尝试引用"><a href="#尝试引用" class="headerlink" title="尝试引用"></a>尝试引用</h3><blockquote><p>一级引用</p><blockquote><p>二级引用<br>…</p></blockquote><p>…</p></blockquote><h3 id="尝试分割线"><a href="#尝试分割线" class="headerlink" title="尝试分割线"></a>尝试分割线</h3><hr><h3 id="尝试图片"><a href="#尝试图片" class="headerlink" title="尝试图片"></a>尝试图片</h3><p><img src="/img/page-1-test.jpg"></p><h3 id="尝试超链接"><a href="#尝试超链接" class="headerlink" title="尝试超链接"></a>尝试超链接</h3><p>点击这里跳转到<a href="https://github.com/Weijinm/Weijinm.github.io">该博客对应的GitHub仓库</a>。</p><h3 id="尝试无序列表（注意空格）"><a href="#尝试无序列表（注意空格）" class="headerlink" title="尝试无序列表（注意空格）"></a>尝试无序列表（注意空格）</h3><ul><li>C</li></ul><ul><li>Java</li></ul><ul><li>Python</li></ul><ul><li>…</li></ul><h3 id="尝试有序列表（注意空格）"><a href="#尝试有序列表（注意空格）" class="headerlink" title="尝试有序列表（注意空格）"></a>尝试有序列表（注意空格）</h3><ol><li>C</li><li>Java</li><li>Python</li></ol><h3 id="尝试表格"><a href="#尝试表格" class="headerlink" title="尝试表格"></a>尝试表格</h3><table><thead><tr><th>序号</th><th>姓名</th><th>学号</th></tr></thead><tbody><tr><td>1</td><td>王小美</td><td>1212xxx</td></tr><tr><td>2</td><td>李小亮</td><td>1212xxx</td></tr><tr><td>3</td><td>张小强</td><td>1213xxx</td></tr></tbody></table><h2 id="之后的安排"><a href="#之后的安排" class="headerlink" title="之后的安排"></a>之后的安排</h2><p>毕竟现在网站还有好多细节啥的没有去完善，最近也已经🐏了，又要期末考，先着手复习，之后再慢慢地弄网站的东西吧，包括各类美化，还有转移部署到我的服务器上去。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
